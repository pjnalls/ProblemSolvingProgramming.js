<h1 align="center"> 
  <br>
  <br>
  <b>Problem-Solving Programming</b> 
  <br>
  (PSP)
  <br>
  <b>Process</b>
  <br>
  <br>
  with
  <br> 
  <b>JavaScript</b>
  <br>
  <br>
  <br>
  <img 
    src="psp.js.png"
    alt="'Problem Solving Programming (PSP) Process with JavaScript' icon."
    width="240px"/>
  <br>
  <br>
</h1>

<h3 align="center">
<br>
<br>
A problem-solving programming (PSP) process for designing and developing JavaScript algorithms in less than 1 hour when given only a single statement for any given problem.
<br>
<br>
</h3>
<br>
<hr>
<br>
<br>

Whether you decide you want to become efficient at problem-solving programming to do well on your technical, code interviews, competitive programming, or simply for the sheer gratification of going from a single problem statement to a fully-functional, test-driven-developed JavaScript algorithm in under an hour without a need for an IDE (integrated-development environment), a good problem-solving process might be fundamental to any of the aforementioned endeavors.

Below are specific, detailed steps I like to keep in mine in a common PSP process:

<br>

1. Carefully read (and/or listen to) the problem statement while assuming that *there is something you do not know*.

<br>

2. Re-read (or ask the speaker to repeat) the problem statement as many times as you need to *get the gist* of what the problem statement requires.

<br>

3. Formulate and ask your questions rather than assuming you *get it* or understand completely. If you're confused, *be comfortable with your confusion* as this gives you the opportunity to ask multiple questions until you have the *clarity* you need before start programming in *confidence*.

<br>

4. Start brainstorming an initial, basic solution with short-handed (or long-handed, if you have time,) comments of each step of the algorithm *before you code* as you explain each step in the algorithm, why you chose each step, and what each step does.

<br>


5. Start testing or *event-storming your brainstorming* for your solution with "what-if" scenarios. You can use your data inputs to test-drive the design of your basic solution â€” accounting for the base cases (from initial brainstormed solution), and then for the best, average, worst, and edge cases.

<br>

6. Summarize your completed, brainstormed, and (now) event-stormed solution to yourself and audibly to others to finalize your solution design until you and everyone else has clarity and now the confidence needed your your solution.

<br>

7. *Finally*, you can start confidently programming your solution. **Remember, the more low-tech your means for programming (e.g., pencil and paper, Notepad, etc.) the harder it is, yet the better programmer you'll become**.

<br>
<br>

As I've attempted to emphasize, programming at any given time is, in many cases, the last thing one should do given a process which is truly problem-solving-programming oriented.

...

**It's more important to truly understand a problem in order for the solution to "write-itself".**

<br>

<hr>

<br>
<br>